"""
Servicio de almacenamiento vectorial usando Chroma
Almacena y busca informaci√≥n de pacientes de forma vectorial
"""

import os
import chromadb
from chromadb.config import Settings
from typing import Dict, Any, List, Optional
from datetime import datetime
import json
import hashlib
import re

from .search_service import SearchService
from .patient_service import PatientService

class VectorStoreService:
    """
    Servicio para almacenamiento vectorial de informaci√≥n m√©dica
    Usa Chroma como base de datos vectorial
    """
    
    def __init__(self, persist_directory: str = "database/vector_db"):
        """
        Inicializa el servicio de almacenamiento vectorial
        
        Args:
            persist_directory: Directorio donde persistir los datos
        """
        self.persist_directory = persist_directory
        self.client = None
        self.patients_collection = None
        self.conversations_collection = None
        self.symptoms_collection = None
        
        # Servicios modulares
        self.search_service = None
        self.patient_service = None
        
        self._setup_chroma()
        self._setup_services()
    
    def _setup_chroma(self):
        """Configura Chroma y crea las colecciones necesarias"""
        try:
            print(f"üîß Configurando Chroma en: {self.persist_directory}")
            
            # Crear directorio si no existe
            os.makedirs(self.persist_directory, exist_ok=True)
            
            # Inicializar cliente Chroma
            self.client = chromadb.PersistentClient(
                path=self.persist_directory,
                settings=Settings(
                    anonymized_telemetry=False,  # Desactivar telemetr√≠a
                    allow_reset=True
                )
            )
            
            # Crear o obtener colecciones
            self._create_collections()
            
            print("‚úÖ Chroma configurado correctamente")
            
        except Exception as e:
            print(f"‚ùå Error configurando Chroma: {e}")
            raise
    
    def _create_collections(self):
        """Crea las colecciones necesarias"""
        try:
            # Colecci√≥n de pacientes
            self.patients_collection = self.client.get_or_create_collection(
                name="patients",
                metadata={"description": "Informaci√≥n vectorial de pacientes"}
            )
            
            # Colecci√≥n de conversaciones
            self.conversations_collection = self.client.get_or_create_collection(
                name="conversations",
                metadata={"description": "Transcripciones y conversaciones vectoriales"}
            )
            
            # Colecci√≥n de s√≠ntomas
            self.symptoms_collection = self.client.get_or_create_collection(
                name="symptoms",
                metadata={"description": "S√≠ntomas m√©dicos vectorizados"}
            )
            
            print("‚úÖ Colecciones creadas/obtenidas correctamente")
            
        except Exception as e:
            print(f"‚ùå Error creando colecciones: {e}")
            raise
    
    def _setup_services(self):
        """Configura los servicios modulares"""
        try:
            self.search_service = SearchService(
                self.conversations_collection, 
                self.patients_collection
            )
            self.patient_service = PatientService(
                self.conversations_collection, 
                self.patients_collection,
                self.persist_directory
            )
            print("‚úÖ Servicios modulares configurados")
        except Exception as e:
            print(f"‚ùå Error configurando servicios: {e}")
            raise
    
    def _generate_embedding_text(self, patient_data: Dict[str, Any]) -> str:
        """
        Genera texto para embeddings: INFORMACI√ìN NO ESTRUCTURADA
        Este texto ser√° vectorizado para b√∫squedas sem√°nticas
        """
        patient_info = patient_data.get('patient_info', {})
        medical_info = patient_data.get('medical_info', {})
        transcription = patient_data.get('transcription', {})
        conversation_details = patient_data.get('conversation_details', {})
        
        # INFORMACI√ìN NO ESTRUCTURADA - Texto natural para vectorizaci√≥n
        embedding_text = f"""
        INFORMACI√ìN DEL PACIENTE:
        Paciente {patient_info.get('name', 'no identificado')} de {patient_info.get('age', 'edad no especificada')} a√±os, 
        g√©nero {patient_info.get('gender', 'no especificado')}.
        
        S√çNTOMAS Y CONTEXTO CONVERSACIONAL:
        El paciente presenta: {', '.join(medical_info.get('symptoms', ['sin s√≠ntomas espec√≠ficos']))}
        
        CONTEXTO M√âDICO:
        Medicamentos mencionados: {', '.join(medical_info.get('medications', ['ninguno mencionado']))}
        Alergias conocidas: {', '.join(medical_info.get('allergies', ['no mencionadas']))}
        Condiciones cr√≥nicas: {', '.join(medical_info.get('chronic_conditions', ['no mencionadas']))}
        
        TRANSCRIPCI√ìN COMPLETA DE LA CONVERSACI√ìN:
        {transcription.get('full_text', 'Sin transcripci√≥n disponible')}
        
        OBSERVACIONES Y CONTEXTO:
        Prioridad de atenci√≥n: {conversation_details.get('priority_level', 'normal')}
        Tipo de conversaci√≥n: {conversation_details.get('conversation_type', 'contacto inicial')}
        Necesita seguimiento: {'S√≠' if conversation_details.get('follow_up_needed') else 'No'}
        Promotor: {conversation_details.get('promoter_id', 'no especificado')}
        Fecha de la conversaci√≥n: {conversation_details.get('conversation_date', 'no especificada')}
        
        AN√ÅLISIS CONTEXTUAL:
        Este paciente se encuentra en una consulta de {conversation_details.get('conversation_type', 'tipo no especificado')} 
        con s√≠ntomas que sugieren {self._extract_diagnosis(transcription.get('full_text', ''))}.
        """
        
        return embedding_text.strip()
    
    def _extract_diagnosis(self, transcription_text: str) -> str:
        """
        Extrae posible diagn√≥stico de la transcripci√≥n
        """
        if not transcription_text:
            return ""
        
        text_lower = transcription_text.lower()
        
        # Patrones de diagn√≥stico comunes
        diagnosis_patterns = [
            r'diagn√≥stico\s*:?\s*([^.]+)',
            r'diagnosis\s*:?\s*([^.]+)',
            r'parece\s+(ser|que\s+es|tener)\s+([^.]+)',
            r'posible\s+([^.]+)',
            r'probable\s+([^.]+)',
            r'sospecha\s+de\s+([^.]+)',
            r'indicativo\s+de\s+([^.]+)',
        ]
        
        # Diagn√≥sticos m√©dicos comunes basados en s√≠ntomas
        symptom_based_diagnosis = {
            'fiebre': ['resfriado com√∫n', 'gripe', 'infecci√≥n viral'],
            'dolor de cabeza': ['migra√±a', 'cefalea tensional', 'sinusitis'],
            'tos': ['bronquitis', 'resfriado', 'irritaci√≥n respiratoria'],
            'dolor de garganta': ['faringitis', 'amigdalitis', 'infecci√≥n viral'],
            'n√°useas': ['gastroenteritis', 'intoxicaci√≥n alimentaria', 'virus estomacal'],
            'diarrea': ['gastroenteritis', 'intoxicaci√≥n alimentaria', 'virus estomacal']
        }
        
        # Buscar diagn√≥stico expl√≠cito
        for pattern in diagnosis_patterns:
            match = re.search(pattern, text_lower)
            if match:
                diagnosis = match.group(1).strip()
                if len(diagnosis) > 3:
                    return diagnosis.title()
        
        # Si no hay diagn√≥stico expl√≠cito, sugerir basado en s√≠ntomas
        for symptom, possible_diagnoses in symptom_based_diagnosis.items():
            if symptom in text_lower:
                return f"Posible {possible_diagnoses[0]} (basado en s√≠ntomas)"
        
        return "Diagn√≥stico pendiente"
    
    def _generate_id(self, patient_data: Dict[str, Any]) -> str:
        """Genera un ID √∫nico para el documento"""
        conversation_id = patient_data.get('conversation_id', '')
        patient_name = patient_data.get('patient_info', {}).get('name', '')
        timestamp = datetime.now().isoformat()
        
        # Crear hash √∫nico
        unique_string = f"{conversation_id}_{patient_name}_{timestamp}"
        return hashlib.md5(unique_string.encode()).hexdigest()
    
    def store_patient_data(self, patient_data: Dict[str, Any]) -> str:
        """
        Almacena los datos del paciente en el almacenamiento vectorial
        
        Args:
            patient_data: Datos del paciente extra√≠dos de la transcripci√≥n
            
        Returns:
            ID del documento almacenado
        """
        try:
            print(f"üíæ Almacenando datos vectoriales para: {patient_data.get('conversation_id', 'N/A')}")
            
            # Generar ID √∫nico
            doc_id = self._generate_id(patient_data)
            
            # Generar texto para embeddings
            embedding_text = self._generate_embedding_text(patient_data)
            
            # INFORMACI√ìN ESTRUCTURADA (Metadatos para b√∫squeda r√°pida)
            metadata = {
                # Informaci√≥n del paciente
                "patient_name": patient_data.get('patient_info', {}).get('name') or " ",
                "patient_age": patient_data.get('patient_info', {}).get('age') or 0,
                "patient_gender": patient_data.get('patient_info', {}).get('gender') or " ",
                "patient_phone": patient_data.get('patient_info', {}).get('contact_info', {}).get('phone') or " ",
                
                # Informaci√≥n m√©dica estructurada
                "diagnosis": self._extract_diagnosis(patient_data.get('transcription', {}).get('full_text', '')) or " ",
                "symptoms_list": json.dumps(patient_data.get('medical_info', {}).get('symptoms', [])),
                "medications_list": json.dumps(patient_data.get('medical_info', {}).get('medications', [])),
                "allergies_list": json.dumps(patient_data.get('medical_info', {}).get('allergies', [])),
                "chronic_conditions": json.dumps(patient_data.get('medical_info', {}).get('chronic_conditions', [])),
                
                # Informaci√≥n de la conversaci√≥n
                "conversation_id": patient_data.get('conversation_id') or " ",
                "conversation_date": patient_data.get('conversation_details', {}).get('conversation_date') or datetime.now().isoformat(),
                "promoter_id": patient_data.get('conversation_details', {}).get('promoter_id') or " ",
                "priority_level": patient_data.get('conversation_details', {}).get('priority_level') or " ",
                "follow_up_needed": bool(patient_data.get('conversation_details', {}).get('follow_up_needed', False)),
                
                # Metadatos t√©cnicos
                "stored_at": datetime.now().isoformat(),
                "conversation_type": patient_data.get('conversation_details', {}).get('conversation_type') or " "
            }
            
            # Almacenar en colecci√≥n de conversaciones
            self.conversations_collection.add(
                documents=[embedding_text],
                metadatas=[metadata],
                ids=[doc_id]
            )
            
            # Tambi√©n almacenar en colecci√≥n de pacientes (si es nuevo paciente)
            self.patient_service.store_patient_summary(patient_data, doc_id)
            
            print(f"‚úÖ Datos vectoriales almacenados con ID: {doc_id}")
            return doc_id
            
        except Exception as e:
            print(f"‚ùå Error almacenando datos vectoriales: {e}")
            raise
    
    # M√©todos delegados a los servicios modulares
    def search_similar_patients(self, query: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_similar_patients(query, n_results)
    
    def search_by_patient_name(self, patient_name: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_by_patient_name(patient_name, n_results)
    
    def search_by_symptoms(self, symptoms: List[str], n_results: int = 5) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_by_symptoms(symptoms, n_results)
    
    def search_by_diagnosis(self, diagnosis_keywords: List[str], n_results: int = 5) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_by_diagnosis(diagnosis_keywords, n_results)
    
    def search_by_date_range(self, start_date: str, end_date: str, n_results: int = 10) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_by_date_range(start_date, end_date, n_results)
    
    def search_by_priority_level(self, priority: str, n_results: int = 10) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_by_priority_level(priority, n_results)
    
    def search_by_promoter(self, promoter_id: str, n_results: int = 10) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_by_promoter(promoter_id, n_results)
    
    def search_complex_query(self, query: str, filters: Dict[str, Any] = None, n_results: int = 5) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_complex_query(query, filters, n_results)
    
    def search_high_priority_patients(self, n_results: int = 10) -> List[Dict[str, Any]]:
        """Delega al SearchService"""
        return self.search_service.search_high_priority_patients(n_results)
    
    def get_patient_summary(self, patient_name: str) -> Dict[str, Any]:
        """Delega al PatientService"""
        return self.patient_service.get_patient_summary(patient_name)
    
    def get_collection_stats(self) -> Dict[str, Any]:
        """Delega al PatientService"""
        return self.patient_service.get_collection_stats()
    
    def export_collection_to_json(self, collection_name: str, file_path: str = None) -> str:
        """Delega al PatientService"""
        return self.patient_service.export_collection_to_json(collection_name, file_path)
    
    def get_patient_conversation_history(self, patient_name: str, limit: int = 10) -> List[Dict[str, Any]]:
        """Delega al PatientService"""
        return self.patient_service.get_patient_conversation_history(patient_name, limit)
    
    def get_patients_by_priority(self, priority: str = "alta") -> List[Dict[str, Any]]:
        """Delega al PatientService"""
        return self.patient_service.get_patients_by_priority(priority)

def test_vector_store():
    """Funci√≥n de prueba para verificar el almacenamiento vectorial"""
    try:
        print("üöÄ Probando almacenamiento vectorial con Chroma...")
        
        # Crear instancia del servicio
        vector_service = VectorStoreService()
        
        # Obtener estad√≠sticas
        stats = vector_service.get_collection_stats()
        print(f"üìä Estad√≠sticas del almacenamiento vectorial: {stats}")
        
        print("‚úÖ Prueba de almacenamiento vectorial completada")
        return True
        
    except Exception as e:
        print(f"‚ùå Error en la prueba de almacenamiento vectorial: {e}")
        return False

if __name__ == "__main__":
    test_vector_store()
